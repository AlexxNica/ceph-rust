var searchIndex = {};
searchIndex["ceph_rust"] = {"doc":"Ceph-rust is a thin layer over the librados C interface. A little higher abstraction layer will\nbe coming next that will encapsulate all of the &quot;C&quot; specific features so that only pure Rust will be needed.","items":[[0,"rados","ceph_rust","",null,null],[3,"AllocFlags","ceph_rust::rados","",null,null],[3,"XattrFlags","","",null,null],[3,"OperationFlags","","",null,null],[3,"Struct_rados_pool_stat_t","","",null,null],[12,"num_bytes","","",0,null],[12,"num_kb","","",0,null],[12,"num_objects","","",0,null],[12,"num_object_clones","","",0,null],[12,"num_object_copies","","",0,null],[12,"num_objects_missing_on_primary","","",0,null],[12,"num_objects_unfound","","",0,null],[12,"num_objects_degraded","","",0,null],[12,"num_rd","","",0,null],[12,"num_rd_kb","","",0,null],[12,"num_wr","","",0,null],[12,"num_wr_kb","","",0,null],[3,"Struct_rados_cluster_stat_t","","",null,null],[12,"kb","","",1,null],[12,"kb_used","","",1,null],[12,"kb_avail","","",1,null],[12,"num_objects","","",1,null],[6,"rados_t","","",null,null],[6,"rados_config_t","","",null,null],[6,"rados_ioctx_t","","",null,null],[6,"rados_list_ctx_t","","",null,null],[6,"rados_snap_t","","",null,null],[6,"rados_xattrs_iter_t","","",null,null],[6,"rados_omap_iter_t","","",null,null],[6,"rados_write_op_t","","",null,null],[6,"rados_read_op_t","","",null,null],[6,"rados_completion_t","","",null,null],[6,"rados_callback_t","","",null,null],[6,"rados_watchcb_t","","",null,null],[6,"rados_watchcb2_t","","",null,null],[6,"rados_watcherrcb_t","","",null,null],[6,"rados_log_callback_t","","",null,null],[17,"LIBRADOS_OP_FLAG_EXCL","","",null,null],[17,"LIBRADOS_OP_FLAG_FAILOK","","",null,null],[17,"LIBRADOS_OP_FLAG_FADVISE_RANDOM","","",null,null],[17,"LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL","","",null,null],[17,"LIBRADOS_OP_FLAG_FADVISE_WILLNEED","","",null,null],[17,"LIBRADOS_OP_FLAG_FADVISE_DONTNEED","","",null,null],[17,"LIBRADOS_OP_FLAG_FADVISE_NOCACHE","","",null,null],[17,"LIBRADOS_CMPXATTR_OP_EQ","","",null,null],[17,"LIBRADOS_CMPXATTR_OP_NE","","",null,null],[17,"LIBRADOS_CMPXATTR_OP_GT","","",null,null],[17,"LIBRADOS_CMPXATTR_OP_GTE","","",null,null],[17,"LIBRADOS_CMPXATTR_OP_LT","","",null,null],[17,"LIBRADOS_CMPXATTR_OP_LTE","","",null,null],[17,"LIBRADOS_OPERATION_NOFLAG","","",null,null],[17,"LIBRADOS_OPERATION_BALANCE_READS","","",null,null],[17,"LIBRADOS_OPERATION_LOCALIZE_READS","","",null,null],[17,"LIBRADOS_OPERATION_ORDER_READS_WRITES","","",null,null],[17,"LIBRADOS_OPERATION_IGNORE_CACHE","","",null,null],[17,"LIBRADOS_OPERATION_SKIPRWLOCKS","","",null,null],[17,"LIBRADOS_OPERATION_IGNORE_OVERLAY","","",null,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"clone","","",2,null],[11,"partial_cmp","","",2,null],[11,"lt","","",2,null],[11,"le","","",2,null],[11,"gt","","",2,null],[11,"ge","","",2,null],[11,"cmp","","",2,null],[11,"hash","","",2,null],[11,"fmt","","",2,null],[11,"empty","","Returns an empty set of flags.",2,{"inputs":[],"output":{"name":"allocflags"}}],[11,"all","","Returns the set containing all flags.",2,{"inputs":[],"output":{"name":"allocflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",2,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",2,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",2,{"inputs":[{"name":"u32"}],"output":{"name":"allocflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",2,null],[11,"is_all","","Returns `true` if all flags are currently set.",2,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",2,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",2,null],[11,"insert","","Inserts the specified flags in-place.",2,null],[11,"remove","","Removes the specified flags in-place.",2,null],[11,"toggle","","Toggles the specified flags in-place.",2,null],[11,"bitor","","Returns the union of the two sets of flags.",2,null],[11,"bitor_assign","","Adds the set of flags.",2,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",2,null],[11,"bitxor_assign","","Toggles the set of flags.",2,null],[11,"bitand","","Returns the intersection between the two sets of flags.",2,null],[11,"bitand_assign","","Disables all flags disabled in the set.",2,null],[11,"sub","","Returns the set difference of the two sets of flags.",2,null],[11,"sub_assign","","Disables all flags enabled in the set.",2,null],[11,"not","","Returns the complement of this set of flags.",2,null],[11,"extend","","",2,null],[11,"from_iter","","",2,{"inputs":[{"name":"t"}],"output":{"name":"allocflags"}}],[11,"clear","","",2,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"clone","","",3,null],[11,"partial_cmp","","",3,null],[11,"lt","","",3,null],[11,"le","","",3,null],[11,"gt","","",3,null],[11,"ge","","",3,null],[11,"cmp","","",3,null],[11,"hash","","",3,null],[11,"fmt","","",3,null],[11,"empty","","Returns an empty set of flags.",3,{"inputs":[],"output":{"name":"xattrflags"}}],[11,"all","","Returns the set containing all flags.",3,{"inputs":[],"output":{"name":"xattrflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",3,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",3,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",3,{"inputs":[{"name":"u32"}],"output":{"name":"xattrflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",3,null],[11,"is_all","","Returns `true` if all flags are currently set.",3,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",3,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",3,null],[11,"insert","","Inserts the specified flags in-place.",3,null],[11,"remove","","Removes the specified flags in-place.",3,null],[11,"toggle","","Toggles the specified flags in-place.",3,null],[11,"bitor","","Returns the union of the two sets of flags.",3,null],[11,"bitor_assign","","Adds the set of flags.",3,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",3,null],[11,"bitxor_assign","","Toggles the set of flags.",3,null],[11,"bitand","","Returns the intersection between the two sets of flags.",3,null],[11,"bitand_assign","","Disables all flags disabled in the set.",3,null],[11,"sub","","Returns the set difference of the two sets of flags.",3,null],[11,"sub_assign","","Disables all flags enabled in the set.",3,null],[11,"not","","Returns the complement of this set of flags.",3,null],[11,"extend","","",3,null],[11,"from_iter","","",3,{"inputs":[{"name":"t"}],"output":{"name":"xattrflags"}}],[11,"clear","","",3,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"clone","","",4,null],[11,"partial_cmp","","",4,null],[11,"lt","","",4,null],[11,"le","","",4,null],[11,"gt","","",4,null],[11,"ge","","",4,null],[11,"cmp","","",4,null],[11,"hash","","",4,null],[11,"fmt","","",4,null],[11,"empty","","Returns an empty set of flags.",4,{"inputs":[],"output":{"name":"operationflags"}}],[11,"all","","Returns the set containing all flags.",4,{"inputs":[],"output":{"name":"operationflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",4,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",4,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",4,{"inputs":[{"name":"u32"}],"output":{"name":"operationflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",4,null],[11,"is_all","","Returns `true` if all flags are currently set.",4,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",4,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",4,null],[11,"insert","","Inserts the specified flags in-place.",4,null],[11,"remove","","Removes the specified flags in-place.",4,null],[11,"toggle","","Toggles the specified flags in-place.",4,null],[11,"bitor","","Returns the union of the two sets of flags.",4,null],[11,"bitor_assign","","Adds the set of flags.",4,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",4,null],[11,"bitxor_assign","","Toggles the set of flags.",4,null],[11,"bitand","","Returns the intersection between the two sets of flags.",4,null],[11,"bitand_assign","","Disables all flags disabled in the set.",4,null],[11,"sub","","Returns the set difference of the two sets of flags.",4,null],[11,"sub_assign","","Disables all flags enabled in the set.",4,null],[11,"not","","Returns the complement of this set of flags.",4,null],[11,"extend","","",4,null],[11,"from_iter","","",4,{"inputs":[{"name":"t"}],"output":{"name":"operationflags"}}],[11,"clear","","",4,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[0,"utils","ceph_rust","",null,null],[5,"run_args","ceph_rust::utils","",null,null],[5,"run_cli","","run_cli - pass in a String of a normal command line",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}]],"paths":[[3,"Struct_rados_pool_stat_t"],[3,"Struct_rados_cluster_stat_t"],[3,"AllocFlags"],[3,"XattrFlags"],[3,"OperationFlags"]]};
searchIndex["ceph"] = {"doc":"","items":[],"paths":[]};
initSearch(searchIndex);
